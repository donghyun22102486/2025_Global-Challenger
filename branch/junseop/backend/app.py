from flask import Flask, request, jsonify
from flask_cors import CORS
import pickle
import pandas as pd
import numpy as np
import os
import datetime


# --- ğŸ‘‡ [ìƒˆë¡œ ì¶”ê°€ëœ Gemini ê´€ë ¨ ë¼ì´ë¸ŒëŸ¬ë¦¬] ğŸ‘‡ ---
import google.generativeai as genai
from dotenv import load_dotenv # python-dotenv ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©
# ---------------------------------------------

# .env íŒŒì¼ì—ì„œ í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
load_dotenv()

app = Flask(__name__)
CORS(app)

# --- ëª¨ë¸ ë° Gemini API í‚¤ ì„¤ì • ---
MODEL_PATH = 'fault_prediction_model.pkl'
model_data = {}

# 1. ê¸°ì¡´ ML ëª¨ë¸ ë¡œë“œ
try:
    with open(MODEL_PATH, 'rb') as f:
        model_data = pickle.load(f)
    print(f"'{MODEL_PATH}' ë¡œë“œ ì„±ê³µ.")
except FileNotFoundError:
    print(f"ê²½ê³ : '{MODEL_PATH}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. 'train_model.py'ë¥¼ ë¨¼ì € ì‹¤í–‰í•´ì£¼ì„¸ìš”.")

# 2. Gemini API í‚¤ ì„¤ì •
try:
    GOOGLE_API_KEY = os.getenv('GOOGLE_API_KEY')
    genai.configure(api_key=GOOGLE_API_KEY)
    print("Gemini API í‚¤ ì„¤ì • ì™„ë£Œ.")
except Exception as e:
    print(f"Gemini API í‚¤ ì„¤ì • ì˜¤ë¥˜: {e}")
# ------------------------------------

def generate_expert_report(fault_type, features):
    """
    Geminië¥¼ ì‚¬ìš©í•˜ì—¬ Lyraì˜ ê³ ë„í™”ëœ í”„ë¡¬í”„íŠ¸ ê¸°ë°˜ìœ¼ë¡œ ì „ë¬¸ê°€ ë³´ê³ ì„œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
    """
    # í”„ë¡¬í”„íŠ¸ì— ë„£ê¸° ìœ„í•´ ë³€ìˆ˜ë“¤ì„ ê°€ê³µí•©ë‹ˆë‹¤.
    feature_list_str = ", ".join([f"'{f['feature']}'" for f in features])
    feature_details_str = "\n".join([f"- **{f['feature']} (ì¤‘ìš”ë„: {f['importance']:.1%}):**" for f in features])
    current_time_str = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    # --- Lyraë‹˜ì˜ í”„ë¡¬í”„íŠ¸ë¥¼ f-stringì— ë§ê²Œ ìˆ˜ì •í•œ ë²„ì „ ---
    # íŒŒì´ì¬ ë³€ìˆ˜ê°€ ì•„ë‹Œ placeholderëŠ” {{...}}ë¡œ ê°ì‹¸ì„œ SyntaxErrorë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.
    prompt = f"""
# í˜ë¥´ì†Œë‚˜ (Persona)
ë‹¹ì‹ ì€ 20ë…„ ê²½ë ¥ì˜ ì² ê°• ì œì¡° ê³µì • í’ˆì§ˆ ê´€ë¦¬(QC) ìˆ˜ì„ ì „ë¬¸ê°€ì´ì, ë³µì¡í•œ ë°ì´í„°ë¥¼ í˜„ì¥ ì‘ì—…ìê°€ ì¦‰ì‹œ í–‰ë™í•  ìˆ˜ ìˆëŠ” ëª…í™•í•˜ê³  êµ¬ì²´ì ì¸ ì§€ì‹œë¡œ ë°”ê¾¸ëŠ” ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ì˜ ëŒ€ê°€ì…ë‹ˆë‹¤. ë‹¹ì‹ ì˜ ì„ë¬´ëŠ” ë‹¨ìˆœíˆ AIì˜ ë¶„ì„ ê²°ê³¼ë¥¼ ì „ë‹¬í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ê·¸ ì•ˆì— ìˆ¨ê²¨ì§„ ì˜ë¯¸ë¥¼ í•´ì„í•˜ê³ , ì ì¬ì  ìœ„í—˜ì„ ì§„ë‹¨í•˜ë©°, ê°€ì¥ íš¨ê³¼ì ì¸ í•´ê²°ì±…ì„ ì œì‹œí•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

# ì»¨í…ìŠ¤íŠ¸ (Context)
ë°©ê¸ˆ AI ì‹¤ì‹œê°„ í’ˆì§ˆ ë¶„ì„ ì‹œìŠ¤í…œ(XGBoost ê¸°ë°˜)ì´ ì•„ë˜ì™€ ê°™ì€ ì˜ˆì¸¡ ê²°ê³¼ë¥¼ ë³´ê³ í–ˆìŠµë‹ˆë‹¤. ì´ ë°ì´í„°ëŠ” ê¸°ê³„ê°€ ë¶„ì„í•œ ìˆœìˆ˜í•œ ì •ë³´ì´ë©°, ë‹¹ì‹ ì€ ì—¬ê¸°ì— ì „ë¬¸ê°€ì˜ í†µì°°ë ¥ì„ ë”í•´ì•¼ í•©ë‹ˆë‹¤.
- ì˜ˆì¸¡ëœ ë¶ˆëŸ‰ ìœ í˜•: "{fault_type}"
- ë¶ˆëŸ‰ ë°œìƒì˜ í•µì‹¬ ì›ì¸ ë³€ìˆ˜ (Top 5): {feature_list_str}

# ì‚¬ê³  ê³¼ì • (Chain-of-Thought) - ë³´ê³ ì„œ ì‘ì„± ì „, ë‹¤ìŒ ë‹¨ê³„ì— ë”°ë¼ ë¨¼ì € ìƒê°í•˜ê³  ê³„íšì„ ìˆ˜ë¦½í•  ê²ƒ.
1.  **ìœ„í—˜ ë“±ê¸‰ ë¶„ë¥˜:** ì˜ˆì¸¡ëœ ë¶ˆëŸ‰ ìœ í˜•('{fault_type}')ì˜ ì ì¬ì  ì‹¬ê°ë„ì™€ ìƒì‚° ë¼ì¸ì— ë¯¸ì¹˜ëŠ” ì˜í–¥ì„ ê³ ë ¤í•˜ì—¬, ìœ„í—˜ ë“±ê¸‰ì„ [ì‹¬ê°], [ê²½ê³ ], [ì£¼ì˜] ì¤‘ í•˜ë‚˜ë¡œ ìì²´ì ìœ¼ë¡œ íŒë‹¨í•œë‹¤. (ì˜ˆ: 'Z_Scratch'ëŠ” ì œí’ˆ ì™¸ê´€ì— ì¹˜ëª…ì ì´ë¯€ë¡œ [ì‹¬ê°], 'Stains'ëŠ” í›„ê³µì •ì—ì„œ ì²˜ë¦¬ ê°€ëŠ¥í•˜ë¯€ë¡œ [ì£¼ì˜]ë¡œ íŒë‹¨)
2.  **ì›ì¸ ë³€ìˆ˜ í•´ì„:** {feature_list_str} ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ” ê° ë³€ìˆ˜ëª…ì´ ì‹¤ì œ ê³µì •ì—ì„œ ì–´ë–¤ ë¬¼ë¦¬ì  ì˜ë¯¸ë¥¼ ê°€ì§€ëŠ”ì§€ êµ¬ì²´ì ìœ¼ë¡œ ì—°ê²°í•œë‹¤. (ì˜ˆ: 'Log_X_Index' -> ê°•íŒì˜ ë„ˆë¹„ ë°©í–¥ ìœ„ì¹˜, 'TypeOfSteel_A300' -> A300 ê°•ì¬ ì‚¬ìš© ì—¬ë¶€)
3.  **ì¢…í•©ì  ì›ì¸ ì¶”ë¡ :** í•´ì„ëœ ë³€ìˆ˜ë“¤ì„ ì¢…í•©í•˜ì—¬, í•˜ë‚˜ì˜ í†µí•©ëœ ë¬¸ì œ ìƒí™© ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ë…¼ë¦¬ì ìœ¼ë¡œ ì¶”ë¡ í•œë‹¤.
4.  **ë‹¨ê³„ë³„ í•´ê²°ì±… ì„¤ê³„:** ì¶”ë¡ ëœ ë¬¸ì œ ìƒí™©ì„ í•´ê²°í•˜ê¸° ìœ„í•œ, ê°€ì¥ ìš°ì„ ìˆœìœ„ê°€ ë†’ê³  ì‹¤í–‰ ê°€ëŠ¥í•œ 1, 2, 3ë‹¨ê³„ì˜ êµ¬ì²´ì ì¸ í–‰ë™ ê³„íšì„ ì„¤ê³„í•œë‹¤.

# ìµœì¢… ë³´ê³ ì„œ í¬ë§· (Output Format) - ìœ„ì˜ ì‚¬ê³  ê³¼ì •ì„ ë°”íƒ•ìœ¼ë¡œ, ì•„ë˜ì˜ í˜•ì‹ì„ ë°˜ë“œì‹œ ì¤€ìˆ˜í•˜ì—¬ ìµœì¢… ë³´ê³ ì„œë¥¼ ì‘ì„±í•  ê²ƒ.

---

### `[ìœ„í—˜ ë“±ê¸‰ ì‚½ì…]` **AI ê³µì • ì „ë¬¸ê°€ ê¸´ê¸‰ ë¦¬í¬íŠ¸**

**1. ìš”ì•½ ë³´ê³ **
> **{fault_type}** ë¶ˆëŸ‰ ë°œìƒ ê°€ëŠ¥ì„±ì´ ë†’ìœ¼ë©°, í•µì‹¬ ì›ì¸ì€ **{{ê°€ì¥ ì¤‘ìš”í•œ ë³€ìˆ˜ 1~2ê°œë¥¼ ì´ìš©í•œ ìš”ì•½}}** ê´€ë ¨ ê³µì •ìœ¼ë¡œ ë³´ì…ë‹ˆë‹¤. ì¦‰ì‹œ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.

**2. ìƒì„¸ ì§„ë‹¨**
AI ë¶„ì„ ì‹œìŠ¤í…œì€ ì´ë²ˆ ë¶ˆëŸ‰ ì˜ˆì¸¡ì˜ í•µì‹¬ ì›ì¸ìœ¼ë¡œ ë‹¤ìŒ ë³€ìˆ˜ë“¤ì„ ì§€ëª©í–ˆìŠµë‹ˆë‹¤.
{feature_details_str} (ê° ë³€ìˆ˜ì˜ ë¬¼ë¦¬ì  ì˜ë¯¸ì™€ í˜„ì¬ ìˆ˜ì¹˜ê°€ ì™œ ë¬¸ì œë˜ëŠ”ì§€ ìƒì„¸íˆ ì„¤ëª…)

ì¢…í•©ì ìœ¼ë¡œ ë³¼ ë•Œ, í˜„ì¬ **{{ì¢…í•©ì  ì›ì¸ ì¶”ë¡  ê²°ê³¼}}** ìƒí™©ì¼ ê°€ëŠ¥ì„±ì´ ë§¤ìš° ë†’ìŠµë‹ˆë‹¤.

**3. [!] ì¦‰ì‹œ ì‹¤í–‰: ë‹¨ê³„ë³„ ì¡°ì¹˜ ê³„íš**
í˜„ì¥ ì‘ì—…ìëŠ” ì•„ë˜ ê³„íšì— ë”°ë¼ ì¦‰ì‹œ ì ê²€ì„ ì‹œì‘í•´ì£¼ì‹­ì‹œì˜¤.

- **1ë‹¨ê³„ (ê°€ì¥ ê°€ëŠ¥ì„± ë†’ì€ ì›ì¸ í™•ì¸):**
  - **ëŒ€ìƒ ì„¤ë¹„/ê³µì •:** {{êµ¬ì²´ì ì¸ ì„¤ë¹„ëª… ë˜ëŠ” ê³µì • ìœ„ì¹˜}}
  - **í™•ì¸ í•­ëª©:** {{í™•ì¸í•´ì•¼ í•  êµ¬ì²´ì ì¸ í•­ëª©, ì˜ˆ: 3ë²ˆ í”„ë ˆìŠ¤ì˜ ì••ë ¥ ê²Œì´ì§€ ê°’}}
  - **ì •ìƒ ê¸°ì¤€:** {{ì •ìƒ ìƒíƒœì˜ ê¸°ì¤€ê°’ ë˜ëŠ” ìƒíƒœ}}

- **2ë‹¨ê³„ (ì—°ê´€ ê³µì • í™•ì¸):**
  - **ëŒ€ìƒ ì„¤ë¹„/ê³µì •:** {{ë‘ ë²ˆì§¸ë¡œ ê°€ëŠ¥ì„± ë†’ì€ ì„¤ë¹„ëª… ë˜ëŠ” ê³µì • ìœ„ì¹˜}}
  - **í™•ì¸ í•­ëª©:** {{í™•ì¸í•´ì•¼ í•  êµ¬ì²´ì ì¸ í•­ëª©}}
  - **ì •ìƒ ê¸°ì¤€:** {{ì •ìƒ ìƒíƒœì˜ ê¸°ì¤€ê°’ ë˜ëŠ” ìƒíƒœ}}

- **3ë‹¨ê³„ (ì›ìì¬/í™˜ê²½ í™•ì¸):**
  - **ëŒ€ìƒ:** {{íˆ¬ì…ëœ ì›ìì¬ ë˜ëŠ” ê³µì • í™˜ê²½ ë³€ìˆ˜}}
  - **í™•ì¸ í•­ëª©:** {{í™•ì¸í•´ì•¼ í•  êµ¬ì²´ì ì¸ í•­ëª©}}

**4. ì¶”ê°€ í™•ì¸ ì‚¬í•­**
> ìœ„ 3ë‹¨ê³„ ì¡°ì¹˜ë¡œ ë¬¸ì œê°€ í•´ê²°ë˜ì§€ ì•Šì„ ê²½ìš°, **{{ì¶”ê°€ë¡œ ì ê²€í•´ë³¼ ë§Œí•œ ì‚¬í•­}}**ì„ í™•ì¸í•˜ê±°ë‚˜ ì¦‰ì‹œ í’ˆì§ˆ ê´€ë¦¬íŒ€ì— ì—°ë½ ë°”ëë‹ˆë‹¤.

**ë³´ê³  ì‹œê°„:** {current_time_str}
"""
    try:
        llm = genai.GenerativeModel('gemini-1.5-flash')
        response = llm.generate_content(prompt)
        return response.text
    except Exception as e:
        print(f"Gemini API í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        return "ì „ë¬¸ê°€ ë³´ê³ ì„œ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. API í‚¤ ë˜ëŠ” ë„¤íŠ¸ì›Œí¬ ìƒíƒœë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”."


@app.route('/api/predict', methods=['POST'])
def predict_fault():
    # ì €ì¥ëœ ëª¨ë¸ ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸
    if not model_data:
        return jsonify({"error": "ëª¨ë¸ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."}), 500
    
    xgb_model = model_data.get('model')
    label_encoder = model_data.get('label_encoder')
    feature_names = model_data.get('feature_names')

    try:
        # --- 1ë‹¨ê³„: ê¸°ì¡´ ML ëª¨ë¸ë¡œ ì˜ˆì¸¡ ë° ë¶„ì„ ---
        input_data = request.get_json()
        ordered_input_values = [input_data[name] for name in feature_names]
        input_df = pd.DataFrame([ordered_input_values], columns=feature_names)
        
        prediction_encoded = xgb_model.predict(input_df)
        prediction_label = label_encoder.inverse_transform(prediction_encoded)[0]
        
        importances = xgb_model.feature_importances_
        feature_importance_df = pd.DataFrame({
            'feature': feature_names,
            'importance': importances
        }).sort_values(by='importance', ascending=False).head(5)
        top_5_features = feature_importance_df.to_dict(orient='records')
        # ---------------------------------------------

        # --- 2ë‹¨ê³„: Geminië¥¼ í˜¸ì¶œí•˜ì—¬ ì „ë¬¸ê°€ ë¦¬í¬íŠ¸ ìƒì„± ---
        expert_report_text = generate_expert_report(prediction_label, top_5_features)
        # ---------------------------------------------

        # --- 3ë‹¨ê³„: ë‘ ê²°ê³¼ë¥¼ í•©ì³ì„œ í”„ë¡ íŠ¸ì—”ë“œë¡œ ì „ë‹¬ ---
        return jsonify({
            'predicted_fault': prediction_label,
            'root_cause_analysis': top_5_features,
            'expert_report': expert_report_text  # ìƒˆë¡œ ì¶”ê°€ëœ í‚¤
        })

    except Exception as e:
        return jsonify({"error": str(e)}), 400


if __name__ == '__main__':
    app.run(debug=True, port=5000)